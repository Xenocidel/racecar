#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <math.h>
#define square(x) x*x
#define get(vec,vec_W,i,j) vec[i*vec_W + j]

class zedNav
{
  ros::NodeHandle nh_;
  ros::NodeHandle private_nh_;

  ros::Publisher pub_;
  ros::Subscriber sub_;


  void callback(const sensor_msgs::Image& msg)
  {
	sensor_msgs::Image edge;
    int i,j;
    int W = msg.width, H = msg.height;
    if (msg.encoding.compare("bgr8")) {
        printf("Match failed\n");
        return;
    }
    edge.header = msg.header;
    edge.height = msg.height;
    edge.width = msg.width;
    edge.encoding = "mono8";
    edge.is_bigendian = msg.is_bigendian;
    edge.step = msg.step/3;
    std::vector <unsigned char> bw;
    for (i=0;i<H;i++) {
        for (j=0;j<W;j++) {
            long sum = 0;
            int k;
            for (k=-1;k<2;k++) sum += msg.data[3*W*i + 3*j +k];
            bw.push_back(sum/3);
            //int index = 3*W*i + j;
            //edge.data.push_back(msg.data[index]);
        }
    }

    int dx,dy;
    for (i=0;i<H;i++) {
        if (i==0 || i==(H-1)) {
            for (j=0;j<W;j++) edge.data.push_back(0);
        }
        else {
            edge.data.push_back(0);
            for (j=1;j<W-1;j++) {
                
                dx = get(bw,W,i,j) - get(bw,W,i,j-1);
                dy = get(bw,W,i-1,j) - get(bw,W,i,j);
                printf("%d, %d, %f%%\n",i,j,(float)edge.data.size()/bw.size()*100);
                /*dx = get(bw,W,i+1,j+1) + 2*get(bw,W,i,j+1) + get(bw,W,i-1,j+1) \
                - (get(bw,W,i+1,j-1) + 2*get(bw,W,i,j-1) + get(bw,W,i-1,j-1));
                printf("dx\n");
                dy = get(bw,W,i-1,j-1) + 2*get(bw,W,i-1,j) + get(bw,W,i-1,j+1) \
                - (get(bw,W,i+1,j-1) + 2*get(bw,W,i+1,j) + get(bw,W,i+1,j+1));
                */
                edge.data.push_back(sqrt(square(dx) + square(dy)));
            }
            edge.data.push_back(0);
        }
    }

    //for (i=0;i<bw.size();i++) edge.data.push_back(bw[i]);

    printf("publishing\n");

    pub_.publish(edge);	
	
  }

  public:
  zedNav():nh_(), private_nh_("~")
  {
	pub_ = nh_.advertise<sensor_msgs::Image>("right_edges",10);
	sub_ = nh_.subscribe("/zed/right/image_raw_color",10,&zedNav::callback,this);

  }
  
};

int main(int argc, char** argv)
{
	ros::init(argc,argv,"zed_nav");
	zedNav zedNav;
	ros::spin();
	return 0;
}


